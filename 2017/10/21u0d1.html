<!-- build time:Mon Oct 29 2018 21:13:10 GMT+0800 (中国标准时间) --><!DOCTYPE HTML><html><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="chrome=1"><div id="squ-side"><div class="squ-sidec"><div style="text-align:left"><a href="javascript:scroll(0,0)"><font size="6">▲</font></a> <a href="/archives/index.html"><i class="icon-copy icon-2x"></i></a> <a href="/index.html"><i class="icon-home icon-2x"></i></a></div></div><div class="squ-sideb"><div class="b">?</div></div></div><title>sed很强大的文本操作命令 | 唔多阁</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><meta name="author" content="(^_^)"><meta name="description" content="sed对文本的处理很强大，并且sed非常小，参数少，容易掌握，他的操作方式根awk有点像。sed按顺序逐行读取文件。然后，它执行为该行指定的所有操作，并在完成请求的修改之后的内容显示出来，也可以存放到文件中。完成了一行上的所有操作之后，它读取文件的下一行，然后重复该过程直到它完成该文件。在这里要注意一点，源文件（默认地）保持不被修改。sed 默认读取整个文件并对其中的每一行进行修改。说白了就是一行"><meta name="description" content="sed对文本的处理很强大，并且sed非常小，参数少，容易掌握，他的操作方式根awk有点像。sed按顺序逐行读取文件。然后，它执行为该行指定的所有操作，并在完成请求的修改之后的内容显示出来，也可以存放到文件中。完成了一行上的所有操作之后，它读取文件的下一行，然后重复该过程直到它完成该文件。在这里要注意一点，源文件（默认地）保持不被修改。sed 默认读取整个文件并对其中的每一行进行修改。说白了就是一行"><meta property="og:type" content="article"><meta property="og:title" content="sed很强大的文本操作命令"><meta property="og:url" content="https://cky2005.github.io/2017/10/21u0d1.html"><meta property="og:site_name" content="唔多阁"><meta property="og:description" content="sed对文本的处理很强大，并且sed非常小，参数少，容易掌握，他的操作方式根awk有点像。sed按顺序逐行读取文件。然后，它执行为该行指定的所有操作，并在完成请求的修改之后的内容显示出来，也可以存放到文件中。完成了一行上的所有操作之后，它读取文件的下一行，然后重复该过程直到它完成该文件。在这里要注意一点，源文件（默认地）保持不被修改。sed 默认读取整个文件并对其中的每一行进行修改。说白了就是一行"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2017-11-05T12:38:44.288Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="sed很强大的文本操作命令"><meta name="twitter:description" content="sed对文本的处理很强大，并且sed非常小，参数少，容易掌握，他的操作方式根awk有点像。sed按顺序逐行读取文件。然后，它执行为该行指定的所有操作，并在完成请求的修改之后的内容显示出来，也可以存放到文件中。完成了一行上的所有操作之后，它读取文件的下一行，然后重复该过程直到它完成该文件。在这里要注意一点，源文件（默认地）保持不被修改。sed 默认读取整个文件并对其中的每一行进行修改。说白了就是一行"><link rel="icon" type="image/x-icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/style.css"></head></html><body><div class="wrapper"><header id="header"><div class="title"><h1><a href="/">唔多阁</a></h1><p><a href="/">(学习笔记,备忘,纯属复制粘贴,无技术含量)</a></p></div><nav class="nav"><ul></ul><div class="clearfix"></div></nav><div class="clearfix"></div></header><div class="content"><article class="post"><header><div class="icon"></div><a href="/2017/10/21u0d1.html"><time datetime="2017-10-21T06:00:17.000Z">2017-10-21</time></a><h1 class="title">sed很强大的文本操作命令</h1></header><div class="entry"><p>sed对文本的处理很强大，并且sed非常小，参数少，容易掌握，他的操作方式根awk有点像。sed按顺序逐行读取文件。然后，它执行为该行指定的所有操作，并在完成请求的修改之后的内容显示出来，也可以存放到文件中。完成了一行上的所有操作之后，它读取文件的下一行，然后重复该过程直到它完成该文件。在这里要注意一点，源文件（默认地）保持不被修改。sed 默认读取整个文件并对其中的每一行进行修改。说白了就是一行一行的操作。我用sed主要就是用里面的替换功能，真的很强大。下面以实例，详细的说一下，先从替换开始，最常用的。<br><a id="more"></a></p><h4 id="一，测试文件test-讲awk时用的一样"><a href="#一，测试文件test-讲awk时用的一样" class="headerlink" title="一，测试文件test,讲awk时用的一样"></a>一，测试文件test,讲awk时用的一样</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">sed -h  </div><div class="line">-n, --quiet, --silent    取消自动打印模式空间  </div><div class="line"> -e 脚本, --expression=脚本   添加“脚本”到程序的运行列表  </div><div class="line"> -f 脚本文件, --file=脚本文件  添加“脚本文件”到程序的运行列表  </div><div class="line"> --follow-symlinks    直接修改文件时跟随软链接  </div><div class="line"> -i[扩展名], --in-place[=扩展名]    直接修改文件(如果指定扩展名就备份文件)  </div><div class="line"> -l N, --line-length=N   指定“l”命令的换行期望长度  </div><div class="line"> --posix  关闭所有 GNU 扩展  </div><div class="line"> -r, --regexp-extended  在脚本中使用扩展正则表达式  </div><div class="line"> -s, --separate  将输入文件视为各个独立的文件而不是一个长的连续输入  </div><div class="line"> -u, --unbuffered  从输入文件读取最少的数据，更频繁的刷新输出  </div><div class="line"> --help     打印帮助并退出  </div><div class="line"> --version  输出版本信息并退出</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"># 用234替换123</div><div class="line">sed -i &quot;s/123/234/&quot; file</div><div class="line"># 加g整行替换所有123</div><div class="line">sed -i &quot;s/123/234/g&quot; file</div><div class="line"># 删除字符串123</div><div class="line">sed -i &quot;s/123//&quot; file</div><div class="line"># 把含有字符串key的行中的more用other替换</div><div class="line">sed -e ‘/key/ s/more/other/’ input-file</div><div class="line"># 从my.txt文件中删除空行,^$ 是正则表达式，其中^表示以什么开头，$表示以什么结尾，两个连载一起就是空行的意思d指令是sed里面的删除，</div><div class="line">sed &apos;/^$/d&apos; my.txt</div><div class="line"># 替换 (&quot;id&quot; : &quot;1234&quot;,) 为 (&quot;id&quot; : &quot;634&quot;,)</div><div class="line">sed -n &apos;/&quot;id&quot;/ s/\(: &quot;.*&quot;\)/: &quot;634&quot;/p&apos; ./123.tmp</div><div class="line"># 显示有port , id , alterId 字符串的行,并且删除行里面的空格.</div><div class="line">sed -n -e &quot;/port/ s/^[ ]*//p&quot; -e &quot;/id/ s/^[ ]*//p&quot; -e &quot;/alterId/ s/^[ ]*//p&quot; ./123.tmp</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"># 在每一行后面增加一空行 </div><div class="line">sed G </div><div class="line"># 将原来的所有空行删除并在每一行后面增加一空行。 </div><div class="line"># 这样在输出的文本中每一行后面将有且只有一空行。 </div><div class="line">sed &apos;/^$/d;G&apos; </div><div class="line"># 在每一行后面增加两行空行 </div><div class="line">sed &apos;G;G&apos; </div><div class="line"># 将第一个脚本所产生的所有空行删除（即删除所有偶数行） </div><div class="line">sed &apos;n;d&apos; </div><div class="line"># 在匹配式样“regex”的行之前插入一空行 </div><div class="line">sed &apos;/regex/&#123;x;p;x;&#125;&apos; </div><div class="line"># 在匹配式样“regex”的行之后插入一空行 </div><div class="line">sed &apos;/regex/G&apos; </div><div class="line"># 在匹配式样“regex”的行之前和之后各插入一空行 </div><div class="line">sed &apos;/regex/&#123;x;p;x;G;&#125;&apos;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">删除空格</div><div class="line">1：行首空格 </div><div class="line">sed &apos;s/^[ \t]*//g&apos; </div><div class="line">说明： </div><div class="line">第一个/的左边是s表示替换，即将空格替换为空 </div><div class="line">第一个/的右边是表示后面的以xx开头 </div><div class="line">中括号表示“或”，空格或tab中的任意一种。这是正则表达式的规范。 </div><div class="line">中括号右边是*，表示一个或多个。 </div><div class="line">第二个和第三个\中间没有东西，表示空 </div><div class="line">g表示替换原来buffer中的，sed在处理字符串的时候并不对源文件进行直接处理，先创建一个buffer，但是加g表示对原buffer进行替换 </div><div class="line">&nbsp</div><div class="line">整体的意思是：用空字符去替换一个或多个用空格或tab开头的本体字符串 </div><div class="line">&nbsp</div><div class="line">2:行末空格 </div><div class="line">sed &apos;s/[ \t]*$//g&apos; </div><div class="line">&nbsp</div><div class="line">和上面稍微有些不同是前面删除了^符，在后面加上了美元符，这表示以xx结尾的字符串为对象。</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">sed [options] -f scriptfile file(s)</div><div class="line">a\（反斜杠）</div><div class="line">在当前行后面加入一行文本。</div><div class="line">&nbsp</div><div class="line">i\</div><div class="line">在当前行上面插入文本。c\用新的文本改变本行的文本。</div><div class="line">&nbsp</div><div class="line">b lable</div><div class="line">分支到脚本中带有标记的地方，如果分支不存在则分支到脚本的末尾。</div><div class="line">d</div><div class="line">从模板块（Pattern space）位置删除行。</div><div class="line">D</div><div class="line">删除模板块的第一行。</div><div class="line">h</div><div class="line">拷贝模板块的内容到内存中的缓冲区。</div><div class="line">H</div><div class="line">追加模板块的内容到内存中的缓冲区</div><div class="line">g</div><div class="line">获得内存缓冲区的内容，并替代当前模板块中的文本。</div><div class="line">G</div><div class="line">获得内存缓冲区的内容，并追加到当前模板块文本的后面。</div><div class="line">l</div><div class="line">列表不能打印字符的清单。</div><div class="line">n</div><div class="line">读取下一个输入行，用下一个命令处理新的行而不是用第一个命令。</div><div class="line">N</div><div class="line">追加下一个输入行到模板块后面并在二者间嵌入一个新行，改变当前行号码。</div><div class="line">p</div><div class="line">打印模板块的行。</div><div class="line">P（大写）</div><div class="line">打印模板块的第一行。</div><div class="line">q</div><div class="line">退出Sed。</div><div class="line">r file</div><div class="line">从file中读行。</div><div class="line">t label</div><div class="line">if分支，从最后一行开始，条件一旦满足或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾。</div><div class="line">T label</div><div class="line">错误分支，从最后一行开始，一旦发生错误或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾。</div><div class="line">w file</div><div class="line">写并追加模板块到file末尾。</div><div class="line">W file</div><div class="line">写并追加模板块的第一行到file末尾。</div><div class="line">!</div><div class="line">表示后面的命令对所有没有被选定的行发生作用。</div><div class="line">‘s/re/string’</div><div class="line">用string替换正则表达式re。</div><div class="line">=</div><div class="line">打印当前行号码。</div><div class="line">#</div><div class="line">把注释扩展到下一个换行符以前。</div><div class="line">以下的是替换标记</div><div class="line">g表示行内全面替换。</div><div class="line">&nbsp</div><div class="line">p表示打印行。</div><div class="line">&nbsp</div><div class="line">w表示把行写入一个文件。</div><div class="line">&nbsp</div><div class="line">x表示互换模板块中的文本和缓冲区中的文本。</div><div class="line">&nbsp</div><div class="line">y表示把一个字符翻译为另外的字符（但是不用于正则表达式）</div><div class="line">&nbsp</div><div class="line">4. 选项</div><div class="line">-e command, --expression=command</div><div class="line">允许多台编辑。</div><div class="line">-h, --help</div><div class="line">打印帮助，并显示bug列表的地址。</div><div class="line">-n, --quiet, --silent</div><div class="line">&nbsp</div><div class="line">取消默认输出。</div><div class="line">-f, --filer=script-file</div><div class="line">引导sed脚本文件名。</div><div class="line">-V, --version</div><div class="line">打印版本和版权信息。</div><div class="line">&nbsp</div><div class="line">5. 元字符集</div><div class="line">&nbsp</div><div class="line">^</div><div class="line">锚定行的开始 如：/^sed/匹配所有以sed开头的行。 </div><div class="line">$</div><div class="line">锚定行的结束 如：/sed$/匹配所有以sed结尾的行。 </div><div class="line">.</div><div class="line">匹配一个非换行符的字符 如：/s.d/匹配s后接一个任意字符，然后是d。 </div><div class="line">*</div><div class="line">匹配零或多个字符 如：/*sed/匹配所有模板是一个或多个空格后紧跟sed的行。 </div><div class="line">[]</div><div class="line">匹配一个指定范围内的字符，如/[Ss]ed/匹配sed和Sed。 </div><div class="line">[^]</div><div class="line">匹配一个不在指定范围内的字符，如：/[^A-RT-Z]ed/匹配不包含A-R和T-Z的一个字母开头，紧跟ed的行。 </div><div class="line">\(..\)</div><div class="line">保存匹配的字符，如s/\(love\)able/\1rs，loveable被替换成lovers。 </div><div class="line">&amp;</div><div class="line">保存搜索字符用来替换其他字符，如s/love/**&amp;**/，love这成**love**。 </div><div class="line">\&lt;</div><div class="line">锚定单词的开始，如:/\&lt;love/匹配包含以love开头的单词的行。 </div><div class="line">\&gt;</div><div class="line">锚定单词的结束，如/love\&gt;/匹配包含以love结尾的单词的行。 </div><div class="line">x\&#123;m\&#125;</div><div class="line">重复字符x，m次，如：/0\&#123;5\&#125;/匹配包含5个o的行。 </div><div class="line">x\&#123;m,\&#125;</div><div class="line">重复字符x,至少m次，如：/o\&#123;5,\&#125;/匹配至少有5个o的行。 </div><div class="line">x\&#123;m,n\&#125;</div><div class="line">重复字符x，至少m次，不多于n次，如：/o\&#123;5,10\&#125;/匹配5--10个o的行。</div><div class="line">6. 实例</div><div class="line">删除：d命令</div><div class="line">$ sed &apos;2d&apos; example-----删除example文件的第二行。</div><div class="line">&nbsp</div><div class="line">$ sed &apos;2,$d&apos; example-----删除example文件的第二行到末尾所有行。</div><div class="line">&nbsp</div><div class="line">$ sed &apos;$d&apos; example-----删除example文件的最后一行。</div><div class="line">&nbsp</div><div class="line">$ sed &apos;/test/&apos;d example-----删除example文件所有包含test的行。</div><div class="line">替换：s命令</div><div class="line">&nbsp</div><div class="line">$ sed &apos;s/test/mytest/g&apos; example-----在整行范围内把test替换为mytest。如果没有g标记，则只有每行第一个匹配的test被替换成mytest。</div><div class="line">&nbsp</div><div class="line">$ sed -n &apos;s/^test/mytest/p&apos; example-----(-n)选项和p标志一起使用表示只打印那些发生替换的行。也就是说，如果某一行开头的test被替换成mytest，就打印它。</div><div class="line">&nbsp</div><div class="line">$ sed &apos;s/^192.168.0.1/&amp;localhost/&apos; example-----&amp;符号表示替换换字符串中被找到的部份。所有以192.168.0.1开头的行都会被替换成它自已加 localhost，变成192.168.0.1localhost。</div><div class="line">&nbsp</div><div class="line">$ sed -n &apos;s/\(love\)able/\1rs/p&apos; example-----love被标记为1，所有loveable会被替换成lovers，而且替换的行会被打印出来。</div><div class="line">&nbsp</div><div class="line">&nbsp</div><div class="line">$ sed &apos;s#10#100#g&apos; example-----不论什么字符，紧跟着s命令的都被认为是新的分隔符，所以，“#”在这里是分隔符，代替了默认的“/”分隔符。表示把所有10替换成100。</div><div class="line">选定行的范围：逗号</div><div class="line">&nbsp</div><div class="line">$ sed -n &apos;/test/,/check/p&apos; example-----所有在模板test和check所确定的范围内的行都被打印。</div><div class="line">&nbsp</div><div class="line">$ sed -n &apos;5,/^test/p&apos; example-----打印从第五行开始到第一个包含以test开始的行之间的所有行。</div><div class="line">&nbsp</div><div class="line">$ sed &apos;/test/,/check/s/$/sed test/&apos; example-----对于模板test和west之间的行，每行的末尾用字符串sed test替换。</div><div class="line">&nbsp</div><div class="line">&nbsp</div><div class="line">多点编辑：e命令</div><div class="line">&nbsp</div><div class="line">$ sed -e &apos;1,5d&apos; -e &apos;s/test/check/&apos; example-----(-e)选项允许在同一行里执行多条命令。如例子所示，第一条命令删除1至5行，第二条命令用check替换test。命令的执 行顺序对结果有影响。如果两个命令都是替换命令，那么第一个替换命令将影响第二个替换命令的结果。</div><div class="line">&nbsp</div><div class="line">&nbsp</div><div class="line">$ sed --expression=&apos;s/test/check/&apos; --expression=&apos;/love/d&apos; example-----一个比-e更好的命令是--expression。它能给sed表达式赋值。</div><div class="line">&nbsp</div><div class="line">&nbsp</div><div class="line">从文件读入：r命令</div><div class="line">$ sed &apos;/test/r file&apos; example-----file里的内容被读进来，显示在与test匹配的行后面，如果匹配多行，则file的内容将显示在所有匹配行的下面。</div><div class="line">&nbsp</div><div class="line">&nbsp</div><div class="line">写入文件：w命令</div><div class="line">$ sed -n &apos;/test/w file&apos; example-----在example中所有包含test的行都被写入file里。</div><div class="line">&nbsp</div><div class="line">&nbsp</div><div class="line">追加命令：a命令</div><div class="line">$ sed &apos;/^test/a\this is an example&apos;  filename       -----this is an example被追加到以filename文件里test开头的行后面，sed要求命令a后面有一个反斜杠。</div><div class="line">&nbsp</div><div class="line"> </div><div class="line">&nbsp</div><div class="line">插入：i命令</div><div class="line">&nbsp</div><div class="line">$ sed &apos;/test/i\new line&apos; filename</div><div class="line">&nbsp</div><div class="line">如果test被匹配，则把反斜杠后面的文本插入到匹配行的前面。</div><div class="line">&nbsp</div><div class="line">&nbsp</div><div class="line">下一个：n命令</div><div class="line">&nbsp</div><div class="line">$ sed &apos;/test/&#123; n; s/aa/bb/; &#125;&apos; example-----如果test被匹配，则移动到匹配行的下一行，替换这一行的aa，变为bb，并打印该行，然后继续。</div><div class="line">&nbsp</div><div class="line">&nbsp</div><div class="line">变形：y命令</div><div class="line">$ sed &apos;1,10y/abcde/ABCDE/&apos; example-----把1--10行内所有abcde转变为大写，注意，正则表达式元字符不能使用这个命令。</div><div class="line">&nbsp</div><div class="line">&nbsp</div><div class="line">退出：q命令</div><div class="line">&nbsp</div><div class="line">$ sed &apos;10q&apos; example-----打印完第10行后，退出sed。</div><div class="line">&nbsp</div><div class="line">&nbsp</div><div class="line">保持和获取：h命令和G命令</div><div class="line">$ sed -e &apos;/test/h&apos; -e &apos;$G example-----在sed处理文件的时候，每一行都被保存在一个叫模式空间的临时缓冲区中，除非行被删除或者输出被取消，否则所有被处理的行都将 打印在屏幕上。接着模式空间被清空，并存入新的一行等待处理。在这个例子里，匹配test的行被找到后，将存入模式空间，h命令将其复制并存入一个称为保 持缓存区的特殊缓冲区内。第二条语句的意思是，当到达最后一行后，G命令取出保持缓冲区的行，然后把它放回模式空间中，且追加到现在已经存在于模式空间中 的行的末尾。在这个例子中就是追加到最后一行。简单来说，任何包含test的行都被复制并追加到该文件的末尾。</div><div class="line">保持和互换：h命令和x命令</div><div class="line">$ sed -e &apos;/test/h&apos; -e &apos;/check/x&apos; example -----互换模式空间和保持缓冲区的内容。也就是把包含test与check的行互换。</div><div class="line">7. 脚本</div><div class="line">Sed脚本是一个sed的命令清单，启动Sed时以-f选项引导脚本文件名。Sed对于脚本中输入的命令非常挑剔，在命令的末尾不能有任何空白或文本，如果在一行中有多个命令，要用分号分隔。以#开头的行为注释行，且不能跨行。</div><div class="line">&nbsp</div><div class="line"> </div><div class="line">&nbsp</div><div class="line">二、sed命令中使用外部变量的方法:</div><div class="line">&nbsp</div><div class="line">1.sed命令使用双引号的情况下，使用$var直接引用</div><div class="line">&nbsp</div><div class="line">$ echo|sed &quot;s/^/$RANDOM.rmvb_/g&quot;</div><div class="line">29328.rmvb_</div><div class="line">&nbsp</div><div class="line"># 上面例子引用了一个环境变量$RANDOM的值</div><div class="line">&nbsp</div><div class="line">2.sed命令使用单引号的情况下，使用&apos;&quot;$var&quot;&apos;引用</div><div class="line">&nbsp</div><div class="line">类似，我们可以看到</div><div class="line">&nbsp</div><div class="line">$ echo|sed &apos;s/^/&apos;&quot;$RANDOM&quot;&apos;.rmvb_/g&apos;</div><div class="line">31338.rmvb_</div></pre></td></tr></table></figure><p>//下面test文件的内容<br></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">root:x:0:0:root:/root:/bin/bash  </div><div class="line">bin:x:1:1:bin:/bin:/bin/false  </div><div class="line">daemon:x:2:2:daemon:/sbin:/bin/false  </div><div class="line">mail:x:8:12:mail:/var/spool/mail:/bin/false  </div><div class="line">ftp:x:14:11:ftp:/home/ftp:/bin/false  </div><div class="line">&amp;amp;nobody:$:99:99:nobody:/:/bin/false  </div><div class="line">zhangy:x:1000:100:,,,:/home/zhangy:/bin/bash  </div><div class="line">http:x:33:33::/srv/http:/bin/false  </div><div class="line">dbus:x:81:81:System message bus:/:/bin/false  </div><div class="line">hal:x:82:82:HAL daemon:/:/bin/false  </div><div class="line">mysql:x:89:89::/var/lib/mysql:/bin/false  </div><div class="line">aaa:x:1001:1001::/home/aaa:/bin/bash  </div><div class="line">ba:x:1002:1002::/home/zhangy:/bin/bash  </div><div class="line">test:x:1003:1003::/home/test:/bin/bash  </div><div class="line">@zhangying:*:1004:1004::/home/test:/bin/bash  </div><div class="line">policykit:x:102:1005:Po</div></pre></td></tr></table></figure><p></p><h4 id="二，举例"><a href="#二，举例" class="headerlink" title="二，举例"></a>二，举例</h4><p>1，替换功能<br></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ sed &apos;s/root/tankzhang/&apos; test |grep tank  </div><div class="line"> tankzhang:x:0:0:root:/root:/bin/bash</div></pre></td></tr></table></figure><p></p><p>上面的这个例子，把test文件中的root替换成tankzhang，只不过只替换一次及终止在这一行的操作，转到下一行</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ sed &apos;s/root/tankzhang/g&apos; test |grep zhang  </div><div class="line"> tankzhang:x:0:0:tankzhang:/tankzhang:/bin/bash  </div><div class="line"> zhangy:x:1000:100:,,,:/home/zhangy:/bin/bash  </div><div class="line"> ba:x:1002:1002::/home/zhangy:/bin/bash  </div><div class="line"> @zhangying:*:1004:1004::/home/test:/bin/bash</div></pre></td></tr></table></figure><p>上面这个例子，用tankzhang把文件test中的root全部替换掉，请注意g这个字母，global的缩写</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ sed -n &apos;s/root/tankzhang/p&apos; test  </div><div class="line"> tankzhang:x:0:0:root:/root:/bin/bash</div></pre></td></tr></table></figure><p>加了-n p后表示只打印那些发生替换的行（部分替换），上面的例子，我并没有加上grep</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ sed -n &apos;s/root/tankzhang/pg&apos; test  </div><div class="line"> tankzhang:x:0:0:tankzhang:/tankzhang:/bin/bash</div></pre></td></tr></table></figure><p>加了-n pg后表示只打印那些发生替换的行（全部替换），上面的例子，我并没有加上grep</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ cat test | sed -ne &apos;2,8s/^zhang/ying/gp&apos;  </div><div class="line"> yingy:x:1000:100:,,,:/home/zhangy:/bin/bash</div></pre></td></tr></table></figure><p>在第二行，到第八行之间，替换以zhang开头的行，用ying来替换，并显示替换的行</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ cat test | sed -n  &apos;2,8s/^zhang/ying/gp;5,10s#dbus#goodbay#gp&apos;  </div><div class="line"> yingy:x:1000:100:,,,:/home/zhangy:/bin/bash  </div><div class="line"> goodbay:x:81:81:System message bus:/:/bin/false</div></pre></td></tr></table></figure><p>当有多个命令要执行时，可以用分号来分开，并且分隔符可以自定义，默认是／。上面的例子意思是在第二行，到第八行之间，替换以zhang开头的行，用ying来替换，在5，到10间，用goodbay来替换dbus，并显示替换的行</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ cat test | sed -ne &apos;2,8s/zhang/ying/gp&apos; -ne  &apos;5,10s#dbus#goodbay#gp&apos;  </div><div class="line">  </div><div class="line">yingy:x:1000:100:,,,:/home/yingy:/bin/bash  </div><div class="line"> goodbay:x:81:81:System message bus:/:/bin/false</div></pre></td></tr></table></figure><p>这个例子根上面的那个例子一样，只不过有一点不同，那就是-e来充当了分号的作用，-e也能分割多个命令。</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ sed -ne &apos;2,8s/^\(zhangy\)/\1ing/gp&apos; test  </div><div class="line"> zhangying:x:1000:100:,,,:/home/zhangy:/bin/bash</div></pre></td></tr></table></figure><p>正则的用法，在sed里面用括号的话要加上\的，不然会报错的。</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ sed -ne &apos;2,15s/zhang/&amp;ying/gp&apos; test  </div><div class="line"> zhangyingy:x:1000:100:,,,:/home/zhangyingy:/bin/bash  </div><div class="line"> ba:x:1002:1002::/home/zhangyingy:/bin/bash  </div><div class="line"> @zhangyingying:*:1004:1004::/home/test:/bin/bash</div></pre></td></tr></table></figure><p>＆的用处是，在找到的字符串后加上＆后面的字符串，zhang后都加上了ying</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ sed -ne &apos;/^zhang/,/Po/s/zhang/ying/gp&apos; test  </div><div class="line"> yingy:x:1000:100:,,,:/home/yingy:/bin/bash  </div><div class="line"> ba:x:1002:1002::/home/yingy:/bin/bash  </div><div class="line"> @yingying:*:1004:1004::/home/test:/bin/bash</div></pre></td></tr></table></figure><p>上面的这个例子是说，在以zhang开头的行开始，到匹配Po的行结束，在他们之间进行替换</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ sed  &apos;/root/&#123;n;s/bin/tank/&#125;&apos; test  </div><div class="line"> root:x:0:0:root:/root:/bin/bash  </div><div class="line"> tank:x:1:1:bin:/bin:/bin/false</div></pre></td></tr></table></figure><p>n;这里的n是next的缩写，找到root的行后，将其下一行的中的bin换成tank</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ sed -e &apos;1,2y/root/ROOT/&apos; test  </div><div class="line"> ROOT:x:0:0:ROOT:/ROOT:/bin/bash  </div><div class="line"> bin:x:1:1:bin:/bin:/bin/false</div></pre></td></tr></table></figure><p>y的作用是将匹配的字符换成大写，不过替换字符和被替换字符长度要一样</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ sed -e &apos;/root/h&apos; -e &apos;$G&apos; test  </div><div class="line">  </div><div class="line">................................  </div><div class="line">  </div><div class="line">.............................  </div><div class="line">  </div><div class="line">ba:x:1002:1002::/home/zhangy:/bin/bash  </div><div class="line"> test:x:1003:1003::/home/test:/bin/bash  </div><div class="line"> @zhangying:*:1004:1004::/home/test:/bin/bash  </div><div class="line">  </div><div class="line">root:x:0:0:root:/root:/bin/bash</div></pre></td></tr></table></figure><p>这个例子中，h的作用是将找到的行，放到一个缓存区，G的作用是将缓存区中的内容放到最后一行。</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ sed -e &apos;/root/h&apos; -e &apos;/zhangy/g&apos; test  </div><div class="line"> root:x:0:0:root:/root:/bin/bash  </div><div class="line"> bin:x:1:1:bin:/bin:/bin/false  </div><div class="line"> daemon:x:2:2:daemon:/sbin:/bin/false  </div><div class="line"> mail:x:8:12:mail:/var/spool/mail:/bin/false  </div><div class="line"> ftp:x:14:11:ftp:/home/ftp:/bin/false  </div><div class="line"> &amp;nobody:$:99:99:nobody:/:/bin/false  </div><div class="line"> root:x:0:0:root:/root:/bin/bash  </div><div class="line"> http:x:33:33::/srv/http:/bin/false  </div><div class="line"> dbus:x:81:81:System message bus:/:/bin/false  </div><div class="line"> hal:x:82:82:HAL daemon:/:/bin/false  </div><div class="line"> mysql:x:89:89::/var/lib/mysql:/bin/false  </div><div class="line"> aaa:x:1001:1001::/home/aaa:/bin/bash  </div><div class="line"> root:x:0:0:root:/root:/bin/bash  </div><div class="line"> test:x:1003:1003::/home/test:/bin/bash  </div><div class="line"> root:x:0:0:root:/root:/bin/bash</div></pre></td></tr></table></figure><p>行替换，用匹配root的行，来替换匹配zhangy的行</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ sed -e &apos;s/bin/tank/g;3q&apos; test  </div><div class="line"> root:x:0:0:root:/root:/tank/bash  </div><div class="line"> tank:x:1:1:tank:/tank:/tank/false  </div><div class="line"> daemon:x:2:2:daemon:/stank:/tank/false</div></pre></td></tr></table></figure><p>3q的意思是到第三行的时候，退出</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ sed -ne &apos;2,15s/zhangy.*[[:digit:]]/=======/gp&apos;  test  </div><div class="line"> =======:,,,:/home/zhangy:/bin/bash  </div><div class="line"> @=======::/home/test:/bin/bash</div></pre></td></tr></table></figure><p>匹配数字别忘了中括号外面还有一个中括号。</p><p>[:alnum:] 字母数字 [a-z A-Z 0-9]<br>[:alpha:] 字母 [a-z A-Z]<br>[:blank:] 空格或制表键<br>[:cntrl:] 任何控制字符<br>[:digit:] 数字 [0-9]<br>[:graph:] 任何可视字符（无空格）<br>[:lower:] 小写 [a-z]<br>[:print:] 非控制字符<br>[:punct:] 标点字符<br>[:space:] 空格<br>[:upper:] 大写 [A-Z]<br>[:xdigit:] 十六进制数字 [0-9 a-f A-F]</p><h4 id="二，删除"><a href="#二，删除" class="headerlink" title="二，删除"></a>二，删除</h4><p>其实我觉得吧，删除其实根替换一样，都是找出来进行一下操作而已，这个过程会牵扯到一些規则而已。</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ sed -e &apos;1,14d&apos; test  </div><div class="line"> @zhangying:*:1004:1004::/home/test:/bin/bash  </div><div class="line"> policykit:x:102:1005:Po</div></pre></td></tr></table></figure><p>删除1，14行</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ sed -e &apos;4,$d&apos; test  </div><div class="line"> root:x:0:0:root:/root:/bin/bash  </div><div class="line"> bin:x:1:1:bin:/bin:/bin/false  </div><div class="line"> daemon:x:2:2:daemon:/sbin:/bin/false</div></pre></td></tr></table></figure><p>删除4以后的行，包括第4行，把$当成最大行数就行了。哈哈</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ sed -e &apos;/\(false\|bash\)$/d&apos; test  </div><div class="line"> policykit:x:102:1005:Po</div></pre></td></tr></table></figure><p>删除包括false的行，或者包括bash的行，别忘了加\</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ sed -e &apos;/root/,/^test/d&apos; test  </div><div class="line"> @zhangying:*:1004:1004::/home/test:/bin/bash  </div><div class="line"> policykit:x:102:1005:Po</div></pre></td></tr></table></figure><p>删除从匹配root的行，到匹配以test开头的行，中间的行</p><h4 id="三，读取，追加，插入文件"><a href="#三，读取，追加，插入文件" class="headerlink" title="三，读取，追加，插入文件"></a>三，读取，追加，插入文件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ sed -e &apos;/^root/r test2&apos; test  </div><div class="line"> root:x:0:0:root:/root:/bin/bash  </div><div class="line"> =============  </div><div class="line"> -------------  </div><div class="line"> +++++++++++++  </div><div class="line"> bin:x:1:1:bin:/bin:/bin/false  </div><div class="line"> daemon:x:2:2:daemon:/sbin:/bin/false</div></pre></td></tr></table></figure><p>读取test2的内容，并将其写入到匹配行的下面</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ sed &apos;/[[:digit:]]/w test2&apos; test</div></pre></td></tr></table></figure><p>将匹配数字的行，写入test2中</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ sed  &apos;/root/a\\ ===aaaa====&apos; test  </div><div class="line"> root:x:0:0:root:/root:/bin/bash  </div><div class="line"> ===aaaa====  </div><div class="line"> bin:x:1:1:bin:/bin:/bin/false</div></pre></td></tr></table></figure><p>将要插入的东西，插入匹配行的下面，</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ sed &apos;/^daemon/i\\=================&apos; test  </div><div class="line"> root:x:0:0:root:/root:/bin/bash  </div><div class="line"> bin:x:1:1:bin:/bin:/bin/false  </div><div class="line"> =================  </div><div class="line"> daemon:x:2:2:daemon:/sbin:/bin/false  </div><div class="line"> mail:x:8:12:mail:/var/spool/mail:/bin/false</div></pre></td></tr></table></figure><p>正好根a相反，将要插入的东西，插入到匹配行的上面</p><h4 id="四，调用命令文件"><a href="#四，调用命令文件" class="headerlink" title="四，调用命令文件"></a>四，调用命令文件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ sed  -f cmd test |awk &apos;&#123;print $0;&#125;&apos;  </div><div class="line"> tank:x:0:0:tank:/tank:/tank/bash  </div><div class="line"> tank:x:1:1:tank:/tank:/tank/false  </div><div class="line"> ba:x:1002:1002::/home/zhangy:/tank/bash  </div><div class="line"> test:x:1003:1003::/home/test:/tank/bash  </div><div class="line"> @zhangying:*:1004:1004::/home/test:/tank/bash</div></pre></td></tr></table></figure><p><a href="http://blog.51yip.com/shell/986.html" target="_blank" rel="external">来源</a></p></div><footer><div class="clearfix"></div></footer></article></div></div><footer id="footer"><div class="copyright">&copy; 2018 <a href="/">(^_^)</a></div><div class="theme-copyright"><a href="javascript:scroll(0,0)">返回顶部</a></div><div class="clearfix"></div></footer><script src="//apps.bdimg.com/libs/jquery/2.0.3/jquery.min.js"></script><script src="/js/all.js"></script><script type="text/javascript">$(document).ready(function(){$(document).on("click",".fold_hider",function(){$(">.fold",this.parentNode).slideToggle(),$(">:first",this).toggleClass("open")}),$("div.fold").css("display","none")})</script></body><!-- rebuild by neat -->