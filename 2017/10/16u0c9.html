<!-- build time:Mon Oct 29 2018 21:13:10 GMT+0800 (中国标准时间) --><!DOCTYPE HTML><html><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="chrome=1"><div id="squ-side"><div class="squ-sidec"><div style="text-align:left"><a href="javascript:scroll(0,0)"><font size="6">▲</font></a> <a href="/archives/index.html"><i class="icon-copy icon-2x"></i></a> <a href="/index.html"><i class="icon-home icon-2x"></i></a></div></div><div class="squ-sideb"><div class="b">?</div></div></div><title>为github仓库减肥 | 唔多阁</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><meta name="author" content="(^_^)"><meta name="description" content="你已经掌握了 Git 的基本用法，只消熟练使用几个常用命令，足以应付开发过程中的绝大多数场景。在 Git 的帮助下，你过上了快乐的生活。然而，某天早上你一觉醒来之后，发现了一件令人纳闷的事情：“为什么我的 Git 仓库变得如此臃肿？”"><meta name="description" content="你已经掌握了 Git 的基本用法，只消熟练使用几个常用命令，足以应付开发过程中的绝大多数场景。在 Git 的帮助下，你过上了快乐的生活。然而，某天早上你一觉醒来之后，发现了一件令人纳闷的事情：“为什么我的 Git 仓库变得如此臃肿？”"><meta property="og:type" content="article"><meta property="og:title" content="为github仓库减肥"><meta property="og:url" content="https://cky2005.github.io/2017/10/16u0c9.html"><meta property="og:site_name" content="唔多阁"><meta property="og:description" content="你已经掌握了 Git 的基本用法，只消熟练使用几个常用命令，足以应付开发过程中的绝大多数场景。在 Git 的帮助下，你过上了快乐的生活。然而，某天早上你一觉醒来之后，发现了一件令人纳闷的事情：“为什么我的 Git 仓库变得如此臃肿？”"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2017-10-16T13:57:37.718Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="为github仓库减肥"><meta name="twitter:description" content="你已经掌握了 Git 的基本用法，只消熟练使用几个常用命令，足以应付开发过程中的绝大多数场景。在 Git 的帮助下，你过上了快乐的生活。然而，某天早上你一觉醒来之后，发现了一件令人纳闷的事情：“为什么我的 Git 仓库变得如此臃肿？”"><link rel="icon" type="image/x-icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/style.css"></head></html><body><div class="wrapper"><header id="header"><div class="title"><h1><a href="/">唔多阁</a></h1><p><a href="/">(学习笔记,备忘,纯属复制粘贴,无技术含量)</a></p></div><nav class="nav"><ul></ul><div class="clearfix"></div></nav><div class="clearfix"></div></header><div class="content"><article class="post"><header><div class="icon"></div><a href="/2017/10/16u0c9.html"><time datetime="2017-10-16T08:00:17.000Z">2017-10-16</time></a><h1 class="title">为github仓库减肥</h1></header><div class="entry"><p>你已经掌握了 Git 的基本用法，只消熟练使用几个常用命令，足以应付开发过程中的绝大多数场景。在 Git 的帮助下，你过上了快乐的生活。然而，某天早上你一觉醒来之后，发现了一件令人纳闷的事情：“为什么我的 Git 仓库变得如此臃肿？”<br><a id="more"></a></p><h3 id="情形一：仓库自身的增长"><a href="#情形一：仓库自身的增长" class="headerlink" title="情形一：仓库自身的增长"></a>情形一：仓库自身的增长</h3><p>大多数版本控制系统存储的是一组初始文件，以及每个文件随着时间的演进而逐步积累起来的差异；而 Git 则会把文件的每一个差异化版本都记录在案（关于 Git 是如何存储数据的，请参阅这篇文章）。这意味着，即使你只改动了某个文件的一行内容，Git 也会生成一个全新的对象来存储新的文件内容。</p><p>如果你改动了一个很大的文件，问题就来了。</p><h4 id="对象碎片"><a href="#对象碎片" class="headerlink" title="对象碎片"></a>对象碎片</h4><p>现在，让我们生成一个包含 1000000 行随机字符串的大文本文件，并把它添加到版本库中：<br></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ perl -le &apos;for (1..1000000) &#123; print map &#123; (0..9, &quot;a&quot;..&quot;z&quot;)[rand 36] &#125; 1..80 &#125;&apos; &gt; bigfile</div><div class="line">$ git add bigfile</div></pre></td></tr></table></figure><p></p><p>我们看到，Git 已经为这个文件生成了一个 Blob 对象，大小是 54M。<br></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ find .git/objects -type f</div><div class="line">.git/objects/7f/a055b2d22855b67287e4e30d9a91584c8b27c1</div><div class="line">$</div><div class="line">$ du -ah    # 此处略去了无关输出</div><div class="line"> 54M    ./.git/objects/7f/a055b2d22855b67287e4e30d9a91584c8b27c1</div><div class="line"> 77M    ./bigfile</div><div class="line">132M    .</div></pre></td></tr></table></figure><p></p><p>如果往文件末尾添加一行，会怎么样呢？<br></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ perl -le &apos;print map &#123; (0..9, &quot;a&quot;..&quot;z&quot;)[rand 36] &#125; 1..80&apos; &gt;&gt; bigfile</div><div class="line">$ git add bigfile</div></pre></td></tr></table></figure><p></p><p>可以看到，Git 生成了一个全新的 Blog 对象来存储新的文件内容，这个对象的大小同样是 54M。仓库瞬间患上了肥胖症。<br></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ find .git/objects -type f</div><div class="line">.git/objects/7f/a055b2d22855b67287e4e30d9a91584c8b27c1</div><div class="line">.git/objects/f3/79c10af3f3e497d37558ac2497fe3c69d2de89</div><div class="line">$</div><div class="line">$ du -ah    # 此处略去了无关输出</div><div class="line"> 54M    ./.git/objects/7f/a055b2d22855b67287e4e30d9a91584c8b27c1</div><div class="line"> 54M    ./.git/objects/f3/79c10af3f3e497d37558ac2497fe3c69d2de89</div><div class="line"> 77M    ./bigfile</div><div class="line">186M    .</div></pre></td></tr></table></figure><p></p><p>你的仓库里面现在有两个内容几乎完全相同，大小均为 54M 的庞大对象。如果 Git 可以只保存其中一个对象，再保存另一个对象与这个对象的差异内容，岂不妙哉？</p><h4 id="gc-命令"><a href="#gc-命令" class="headerlink" title="gc 命令"></a>gc 命令</h4><p>“垃圾回收”是一个很亲切的功能。让我们开始吧：<br></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">git gc --prune=now</div></pre></td></tr></table></figure><p></p><p>现在，重新检视一下仓库的大小，发现确实有效啊：<br></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ find .git/objects -type f</div><div class="line">.git/objects/info/packs</div><div class="line">.git/objects/pack/pack-9d75315485cb7bfbf51ce5c94a4535da99b58dbb.idx</div><div class="line">.git/objects/pack/pack-9d75315485cb7bfbf51ce5c94a4535da99b58dbb.pack</div><div class="line">$</div><div class="line">$ du -ah    # 此处略去了无关输出</div><div class="line">4.0K    ./.git/objects/pack/pack-9d75315485cb7bfbf51ce5c94a4535da99b58dbb.idx</div><div class="line"> 52M    ./.git/objects/pack/pack-9d75315485cb7bfbf51ce5c94a4535da99b58dbb.pack</div><div class="line"> 77M    ./bigfile</div><div class="line">130M    .</div></pre></td></tr></table></figure><p></p><p>运行 gc 命令之后，两个 Blob 对象不见了。Git 创建了一个包文件和一个索引文件。包文件中包含了之前的两个 Blob 对象，索引文件中包含了每个对象在包文件中的偏移信息。Git 在打包的过程中使用了增量编码方案（delta encoding），只保存对象的不同版本之间的差异，这使得仓库瘦身成功。</p><h4 id="不过…"><a href="#不过…" class="headerlink" title="不过…"></a>不过…</h4><p>实际上，你并不需要手动调用 gc 命令。每当碎片对象过多，或者你向远端服务器发起推送的时候，Git 就会自动执行一次打包过程。</p><h3 id="情形二：错误的大文件"><a href="#情形二：错误的大文件" class="headerlink" title="情形二：错误的大文件"></a>情形二：错误的大文件</h3><p>让我们添加一个名为 new.txt 的新文件，并且执行两次提交：<br></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ git commit -m &quot;first commit&quot;</div><div class="line">$ echo &apos;new file&apos; &gt; new.txt</div><div class="line">$ git commit -a &quot;second commit&quot;</div></pre></td></tr></table></figure><p></p><p>当执行第二次提交的时候，你突然发现，其实 bigfile 这个文件在项目中并没什么卵用。然而它很大。即使你把这个文件从项目中移除了，它还是会顽固地永远存在于你的提交历史中。有没有办法把这个文件从历次提交中彻底地移除呢？</p><p>办法是有的，不过务必要谨慎哦。</p><p>能够胜任这个任务的命令叫做 filter-branch：<br></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ git filter-branch --force --index-filter \</div><div class="line">  &apos;git rm --cached --ignore-unmatch bigfile&apos; \</div><div class="line">  --prune-empty --tag-name-filter cat -- --all</div><div class="line">Rewrite 1d92bc51b15c80582cef9cfb27ee056f000590bc (1/2)rm &apos;bigfile&apos;</div><div class="line">Rewrite 4ef010df40a1e81b1f9a11391d63879b649e9690 (2/2)rm &apos;bigfile&apos;</div><div class="line">&nbsp</div><div class="line">Ref &apos;refs/heads/master&apos; was rewritten</div></pre></td></tr></table></figure><p></p><p>然后，删除缓存的对象。这一步可以暂时跳过，等到确认完全不会出现问题之后再执行（可以说，这些缓存对象给你提供了撤销操作的最后一次机会）。<br></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ git for-each-ref --format=&apos;delete %(refname)&apos; refs/original | git update-ref --stdin</div><div class="line">$ git reflog expire --expire=now --all</div><div class="line">$ git gc --prune=now</div></pre></td></tr></table></figure><p></p><p>现在仓库的总大小只有 88K 了，是不是很棒：<br></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ du -ah    # 此处略去了无关输出</div><div class="line">4.0K    ./.git/objects/pack/pack-846da79290b3ef2f6617aa8aab03e4f54439a40a.idx</div><div class="line">4.0K    ./.git/objects/pack/pack-846da79290b3ef2f6617aa8aab03e4f54439a40a.pack</div><div class="line">4.0K    ./new.txt</div><div class="line"> 88K    .</div></pre></td></tr></table></figure><p></p><p>当然，你可能还需要把这一次的改动提交到远端仓库：<br></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ git push --force --verbose --dry-run</div><div class="line">$ git push --force</div></pre></td></tr></table></figure><p></p><p><a href="http://www.jianshu.com/p/7231b509c279" target="_blank" rel="external">來源</a></p></div><footer><div class="clearfix"></div></footer></article></div></div><footer id="footer"><div class="copyright">&copy; 2018 <a href="/">(^_^)</a></div><div class="theme-copyright"><a href="javascript:scroll(0,0)">返回顶部</a></div><div class="clearfix"></div></footer><script src="//apps.bdimg.com/libs/jquery/2.0.3/jquery.min.js"></script><script src="/js/all.js"></script><script type="text/javascript">$(document).ready(function(){$(document).on("click",".fold_hider",function(){$(">.fold",this.parentNode).slideToggle(),$(">:first",this).toggleClass("open")}),$("div.fold").css("display","none")})</script></body><!-- rebuild by neat -->